local M = {}

local Path = require('plenary.path')
local config = require('possession.config')
local cleanup = require('possession.cleanup')
local utils = require('possession.utils')

-- Save current session
--
--@param vimscript string?: mksession-generated commands
--@param no_confirm boolean: do not ask when overwriting existing file
function M.save(name, opts)
    opts = vim.tbl_extend('force', {
        vimscript = nil,
        no_confirm = false,
    }, opts or {})

    vim.validate {
        name = { name, 'string' },
        vimscript = { opts.vimscript, { 'nil', 'string' } },
        no_confirm = { opts.no_confirm, 'boolean' },
    }

    -- Get user data to store, abort on false/nil
    local user_data = config.hooks.before_save(name)
    if not user_data then
        return
    end

    -- Run builtin cleanup
    if not cleanup.run('before_save') then
        return
    end

    -- Generate data for serialization
    local session_data = {
        name = name,
        vimscript = opts.vimscript or utils.mksession(),
        cwd = vim.fn.getcwd(),
        user_data = user_data,
    }

    -- Write to disk
    local path = utils.session_path(name)
    local short = utils.session_path_short(name)
    local commit = function(ok)
        if ok then
            vim.fn.mkdir(config.session_dir, 'p')
            path:write(vim.json.encode(session_data), 'w')
            utils.info('Saved as "%s"', short)
        else
            utils.info('Aborting')
        end

        cleanup.run('after_save')
        config.hooks.after_save(name, user_data, not ok)
    end

    if path:exists() and not opts.no_confirm then
        local prompt = string.format('File "%s" exists, overwrite? [yN] ', short)
        vim.ui.input({ prompt = prompt }, function(answer)
            commit(vim.tbl_contains({ 'y', 'yes' }, answer:lower()))
        end)
    else
        commit(true)
    end
end

-- Load session by name (or from raw data)
--
--@param name_or_data string|table: name if string, else a table with raw
-- data that will be saved as the session file in JSON format.
function M.load(name_or_data)
    vim.validate { name_or_data = { name_or_data, { 'string', 'table' } } }

    -- Load session data
    local session_data = name_or_data
    if type(name_or_data) == 'string' then
        local path = utils.session_path(name_or_data)
        session_data = vim.json.decode(path:read())
    else
        session_data = name_or_data
    end

    -- Run pre-load hook that can pre-process user data, abort if returns falsy value.
    local user_data = config.hooks.before_load(session_data.name, session_data.user_data)
    if not user_data then
        return
    end

    -- Run builtin cleanup
    if not cleanup.run('before_load') then
        return
    end

    -- Source the Vimscript generated by mksession
    vim.api.nvim_exec(session_data.vimscript, false)

    cleanup.run('after_load')
    config.hooks.after_load(session_data.name, user_data)

    utils.info('Loaded session "%s"', session_data.name)
end

-- Delete session by name
function M.delete(name)
    vim.validate { name = { name, 'string' } }

    local path = utils.session_path(name)
    local short = utils.session_path_short(name)

    if vim.fn.delete(path:absolute()) ~= 0 then
        vim.notify(string.format('Failed to delete session: "%s"', short), vim.log.levels.ERROR)
    else
        utils.info('Deleted "%s"', short)
    end
end

-- Get a list of sessions
--@param no_read boolean: do not read/parse session files, just scan the directory
--@return table: depending on `no_read` this will be:
--  no_read=false: table of {filename: session_data} for all available sessions
--  no_read=true: table of {filename: true}
function M.list(opts)
    opts = vim.tbl_extend('force', {
        no_read = true,
    }, opts or {})

    local sessions = {}
    local glob = utils.session_path('*'):absolute()
    for _, file in ipairs(vim.fn.glob(glob, true, true)) do
        local path = Path:new(file)
        local data = opts.no_read and vim.json.decode(path:read()) or path:absolute()
        sessions[file] = data
    end

    return sessions
end

return M
